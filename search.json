[
  {
    "objectID": "chapters/chapter_04/online_polyglot_notebooks_demo.html",
    "href": "chapters/chapter_04/online_polyglot_notebooks_demo.html",
    "title": "使用 Visual Studio Code 和 Polyglot Notebooks 擴充套件測試Grain的RPC方法實做",
    "section": "",
    "text": "需要安裝的軟體有：\n\n.NET 6 SDK\nVisual Studio Code\nVisual Studio Code的C#擴充套件。\nVisual Studio Code的Polyglot Notebooks擴充套件。\nPowerShell Core (v7.+)，在目前Windows, macOS, Linux各種主流版本發佈的作業系統安裝都有支援。\n\n\n\n\n\n\n在Visual Studio Code中，按下 Ctrl(Cmd)+Shift+P以便叫出 Command Palette 命令選擇區命令列，然後輸入new notebook以便篩選可用選項：\n\n選擇.NET Interactive: Create new blank notebook，然後按下 Enter。\n選擇要使用的檔案格式，如果需要在非Visual Studio Code的 .NET Interactive這個擴充套件提供的UI中執行，或不需實際執行就能看到內容的場合(如GitHub網頁上)，選擇傳統Jupyter Notebook的 .ipynb 格式，然後按 Enter：\n\n選擇Notebook檔案主要使用的程式語言，此處選 C#，然後按 Enter。\n\n此時空白的Notebook檔案就已建立完成，可以開始撰寫程式碼了。\n\n\n在Notebook檔案中，可以打程式碼按 Ctrl + Enter 執行程式的UI部分，以下簡稱『Code Cell』以方便進行說明。\n\n\n\n\n\n\n首先在昨天程式碼專案的根目錄，建立一個 notebooks 目錄，然後在此目錄內建立一個 .NET Interactive Notebooks檔案。\n建立一個『Code Cell』輸入以下內容，以便安裝Nuget套件：\n#region install Nuget\n//Essential libs for running .NET 6 Generic Host\n#r \"nuget: Microsoft.Extensions.Hosting\"\n#r \"nuget: Microsoft.Extensions.DependencyInjection\"\n\n//Orleans essential dependencies\n#r \"nuget: Microsoft.Orleans.Core\"\n#r \"nuget: Microsoft.Orleans.OrleansRuntime\"\n//Orleans silo server runtime essentials\n#r \"nuget: Microsoft.Orleans.Server\"\n#endregion\n接在後面再建立一個『Code Cell』輸入以下內容，以便引入命名空間(namespace)：\nusing Microsoft.Extensions.Hosting;\nusing Orleans;\nusing Orleans.Runtime;\nusing Orleans.Hosting;\n由於 .NET Interactive的底層C#實作是使用C# Script(.csx檔)，不支援自定義命名空間，因此我們定義RPC介面和Grain實作類別不以把程式碼寫在『Code Cell』裡的方式，而是在Code Cell內用PowerShell命令來呼叫dotnet CLI編譯建置先前已經定義好的Grain實作類別專案：\n#!pwsh\ndotnet build ../src/Grains/RpcDemo.Grains.Greeting/RpcDemo.Grains.Greeting.csproj --nologo --verbosity quiet\n魔術命令(magic command)『#!pwsh』表示此Code Cell中，該標記之後的內容是使用PowerShell來解譯/執行的命令。\n接在後面再建立一個『Code Cell』輸入以下內容，以便載入編譯好的Grain實作類別：\n#r \"../src/Shared/RpcDemo.Interfaces.Hello/bin/Debug/netstandard2.0/RpcDemo.Interfaces.Hello.dll\"\n#r \"../src/Grains/RpcDemo.Grains.Greeting/bin/Debug/net6.0/RpcDemo.Grains.Greeting.dll\"\n接在後面再建立一個『Code Cell』，輸入起始化Orleans Silo的Generic HostBuilder配置程式碼：\nusing RpcDemo.Interfaces.Hello;\nusing RpcDemo.Grains.Greeting;\nvar hostBuilder = Host.CreateDefaultBuilder()\n    .UseOrleans(builder =&gt;\n    {\n        builder.UseLocalhostClustering();\n        builder.ConfigureApplicationParts(parts =&gt; {\n          parts.AddApplicationPart(typeof(IHelloGrain).Assembly).WithReferences();\n          parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences();\n        });\n    });\nMicrosoft Orleans框架提供一個UseOrleans()擴充方法來整合至ASP.NET Core的web服務框架/.NET Generic Host中執行Silo的服務實體，而餵給該方法的Lambda敘述式參數中，第一行UseLocalhostClustering()設定Silo使用本機端測試叢集，第二行呼叫SiloBuilder的 ConfigureApplicationParts() 擴充方法來載入HelloGrain實作類別的Assembly，並且使用另一個 WithReferences() 擴充方法來載入該Grain實作類別的程式中有用到的其他相依類別。\n這裡要注意的是，由於.NET Interactive底層的Nested Kernel機制，所以在.NET Interactive Notebook中宣告的SiloBuilder除了要宣告載入Grain實作類別之外，RPC介面的Interface型別也得要明確寫出載入宣告。\n然後上述的配置無誤的話，呼叫hostBuilder的Build()建置方法來產生一個Generic Host實體，並且呼叫StartAsync()方法來啟動承載本機Silo測試叢集的.NET Generic Host服務實體：\nvar host = hostBuilder.Build();\nawait host.StartAsync();\n再來我們開始配置Orleans呼叫RPC客戶端的ClientBuilder程式碼：\nvar clientBuilder = new ClientBuilder().UseLocalhostClustering();\nclientBuilder.ConfigureApplicationParts(parts=&gt;parts.AddApplicationPart(typeof(IHelloGrain).Assembly));\n與Server端類似，在Client端也有個UseLocalhostClustering()擴充方法設定連結本機端測試叢集的Silo服務，然後也有相對應載入RPC介面的Assembly的機制。\n配置無誤的話，呼叫Build()建置方法產生Orleans Client端物件：\nvar client = clientBuilder.Build();\n和Silo連線：\nawait client.Connect();\n建立HelloGrain實體的Client端參考(RPC proxy)：\nvar helloGrainRpc = client.GetGrain&lt;IHelloGrain&gt;(0);\n呼叫Grain的RPC方法：\nvar greeting = await helloGrainRpc.SayHello(\"Orleans\");\ndisplay(greeting);\n這裡要注意的是，最後一行的 display() 是 .NET Interactive Notebook C# Kernel的特殊函式可印出變數值，執行的結果如下圖所示：\n\n呼叫結束後，如果RPC proxy不再使用時，關閉Client端連線：\nawait client.Close();\n最後記得呼叫StopAsync()方法來關閉.NET Generic Host服務實體：\nawait host.StopAsync().ConfigureAwait(false);\n\n以上是使用 .NET Interactive Notebook 來撰寫Orleans的範例，這個範例可直接從GitHub的預覽網頁上看到：\nhttps://github.com/OAAB_Book//blob/chapters/chapter_04/notebooks/verify_HelloGrain.ipynb"
  },
  {
    "objectID": "chapters/chapter_04/online_polyglot_notebooks_demo.html#建立-poloyglot-notebooks",
    "href": "chapters/chapter_04/online_polyglot_notebooks_demo.html#建立-poloyglot-notebooks",
    "title": "使用 Visual Studio Code 和 Polyglot Notebooks 擴充套件測試Grain的RPC方法實做",
    "section": "",
    "text": "在Visual Studio Code中，按下 Ctrl(Cmd)+Shift+P以便叫出 Command Palette 命令選擇區命令列，然後輸入new notebook以便篩選可用選項：\n\n選擇.NET Interactive: Create new blank notebook，然後按下 Enter。\n選擇要使用的檔案格式，如果需要在非Visual Studio Code的 .NET Interactive這個擴充套件提供的UI中執行，或不需實際執行就能看到內容的場合(如GitHub網頁上)，選擇傳統Jupyter Notebook的 .ipynb 格式，然後按 Enter：\n\n選擇Notebook檔案主要使用的程式語言，此處選 C#，然後按 Enter。\n\n此時空白的Notebook檔案就已建立完成，可以開始撰寫程式碼了。\n\n\n在Notebook檔案中，可以打程式碼按 Ctrl + Enter 執行程式的UI部分，以下簡稱『Code Cell』以方便進行說明。\n\n\n\n\n\n\n首先在昨天程式碼專案的根目錄，建立一個 notebooks 目錄，然後在此目錄內建立一個 .NET Interactive Notebooks檔案。\n建立一個『Code Cell』輸入以下內容，以便安裝Nuget套件：\n#region install Nuget\n//Essential libs for running .NET 6 Generic Host\n#r \"nuget: Microsoft.Extensions.Hosting\"\n#r \"nuget: Microsoft.Extensions.DependencyInjection\"\n\n//Orleans essential dependencies\n#r \"nuget: Microsoft.Orleans.Core\"\n#r \"nuget: Microsoft.Orleans.OrleansRuntime\"\n//Orleans silo server runtime essentials\n#r \"nuget: Microsoft.Orleans.Server\"\n#endregion\n接在後面再建立一個『Code Cell』輸入以下內容，以便引入命名空間(namespace)：\nusing Microsoft.Extensions.Hosting;\nusing Orleans;\nusing Orleans.Runtime;\nusing Orleans.Hosting;\n由於 .NET Interactive的底層C#實作是使用C# Script(.csx檔)，不支援自定義命名空間，因此我們定義RPC介面和Grain實作類別不以把程式碼寫在『Code Cell』裡的方式，而是在Code Cell內用PowerShell命令來呼叫dotnet CLI編譯建置先前已經定義好的Grain實作類別專案：\n#!pwsh\ndotnet build ../src/Grains/RpcDemo.Grains.Greeting/RpcDemo.Grains.Greeting.csproj --nologo --verbosity quiet\n魔術命令(magic command)『#!pwsh』表示此Code Cell中，該標記之後的內容是使用PowerShell來解譯/執行的命令。\n接在後面再建立一個『Code Cell』輸入以下內容，以便載入編譯好的Grain實作類別：\n#r \"../src/Shared/RpcDemo.Interfaces.Hello/bin/Debug/netstandard2.0/RpcDemo.Interfaces.Hello.dll\"\n#r \"../src/Grains/RpcDemo.Grains.Greeting/bin/Debug/net6.0/RpcDemo.Grains.Greeting.dll\"\n接在後面再建立一個『Code Cell』，輸入起始化Orleans Silo的Generic HostBuilder配置程式碼：\nusing RpcDemo.Interfaces.Hello;\nusing RpcDemo.Grains.Greeting;\nvar hostBuilder = Host.CreateDefaultBuilder()\n    .UseOrleans(builder =&gt;\n    {\n        builder.UseLocalhostClustering();\n        builder.ConfigureApplicationParts(parts =&gt; {\n          parts.AddApplicationPart(typeof(IHelloGrain).Assembly).WithReferences();\n          parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences();\n        });\n    });\nMicrosoft Orleans框架提供一個UseOrleans()擴充方法來整合至ASP.NET Core的web服務框架/.NET Generic Host中執行Silo的服務實體，而餵給該方法的Lambda敘述式參數中，第一行UseLocalhostClustering()設定Silo使用本機端測試叢集，第二行呼叫SiloBuilder的 ConfigureApplicationParts() 擴充方法來載入HelloGrain實作類別的Assembly，並且使用另一個 WithReferences() 擴充方法來載入該Grain實作類別的程式中有用到的其他相依類別。\n這裡要注意的是，由於.NET Interactive底層的Nested Kernel機制，所以在.NET Interactive Notebook中宣告的SiloBuilder除了要宣告載入Grain實作類別之外，RPC介面的Interface型別也得要明確寫出載入宣告。\n然後上述的配置無誤的話，呼叫hostBuilder的Build()建置方法來產生一個Generic Host實體，並且呼叫StartAsync()方法來啟動承載本機Silo測試叢集的.NET Generic Host服務實體：\nvar host = hostBuilder.Build();\nawait host.StartAsync();\n再來我們開始配置Orleans呼叫RPC客戶端的ClientBuilder程式碼：\nvar clientBuilder = new ClientBuilder().UseLocalhostClustering();\nclientBuilder.ConfigureApplicationParts(parts=&gt;parts.AddApplicationPart(typeof(IHelloGrain).Assembly));\n與Server端類似，在Client端也有個UseLocalhostClustering()擴充方法設定連結本機端測試叢集的Silo服務，然後也有相對應載入RPC介面的Assembly的機制。\n配置無誤的話，呼叫Build()建置方法產生Orleans Client端物件：\nvar client = clientBuilder.Build();\n和Silo連線：\nawait client.Connect();\n建立HelloGrain實體的Client端參考(RPC proxy)：\nvar helloGrainRpc = client.GetGrain&lt;IHelloGrain&gt;(0);\n呼叫Grain的RPC方法：\nvar greeting = await helloGrainRpc.SayHello(\"Orleans\");\ndisplay(greeting);\n這裡要注意的是，最後一行的 display() 是 .NET Interactive Notebook C# Kernel的特殊函式可印出變數值，執行的結果如下圖所示：\n\n呼叫結束後，如果RPC proxy不再使用時，關閉Client端連線：\nawait client.Close();\n最後記得呼叫StopAsync()方法來關閉.NET Generic Host服務實體：\nawait host.StopAsync().ConfigureAwait(false);\n\n以上是使用 .NET Interactive Notebook 來撰寫Orleans的範例，這個範例可直接從GitHub的預覽網頁上看到：\nhttps://github.com/OAAB_Book//blob/chapters/chapter_04/notebooks/verify_HelloGrain.ipynb"
  },
  {
    "objectID": "chapters/chapter_04/online.html",
    "href": "chapters/chapter_04/online.html",
    "title": "相關網路連結",
    "section": "",
    "text": "相關網路連結\n\n.NET 6 SDK\nVisual Studio Code\nVisual Studio Code的C#擴充套件。\nVisual Studio Code的Polyglot Notebooks擴充套件。\nPowerShell Core (v7.+)\n\n\n\n實做範例\n\n使用 Visual Studio Code 和 Polyglotm Notebooks 擴充套件測試Grain的RPC方法實做"
  }
]